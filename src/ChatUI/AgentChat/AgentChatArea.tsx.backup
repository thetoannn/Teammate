import React, { useState } from "react";

import { AgentChatInput } from "./AgentChatInput";
import { AgentChatService } from "./AgentChatService";
import { AgentMessage as AgentMessageType } from "./AgentChatTypes";
import AgentMessage from "./components/AgentMessage";

interface AgentChatAreaProps {
  agentId?: string;
  sessionId?: string;
}

export const AgentChatArea: React.FC<AgentChatAreaProps> = ({
  agentId,
  sessionId = "default-session",
}) => {
  const [messages, setMessages] = useState<AgentMessageType[]>([]);
  const [isTyping, setIsTyping] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [currentAgent, setCurrentAgent] = useState<string | null>(null);
  const chatService = AgentChatService.getInstance();

  const handleSendMessage = async (message: string) => {
    if (!message.trim()) return;

    const userMessage: AgentMessageType = {
      id: `user-${Date.now()}`,
      content: message,
      type: "text",
      timestamp: new Date(),
      sender: "user",
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsTyping(true);
    setCurrentAgent("AI");

    // Create initial AI message that will be updated with streaming content
    const initialAiMessage: AgentMessageType = {
      id: `ai-${Date.now()}`,
      content: "",
      type: "text",
      timestamp: new Date(),
      sender: "ai",
      metadata: { agentName: "AI" },
    };

    setMessages((prev) => [...prev, initialAiMessage]);

    try {
      console.log("üîÑ About to call runSuperAgent with:", {
        sessionId,
        message,
      });

      const response = await chatService.runSuperAgent(sessionId, message);

      console.log("‚úÖ runSuperAgent completed, response received:", {
        ok: response.ok,
        status: response.status,
        hasBody: !!response.body,
        contentType: response.headers.get("content-type"),
      });

      console.log("üîÑ About to call processStreamingResponse...");

      const result = await chatService.processStreamingResponse(
        response,
        // onChunk callback - update the message content as chunks arrive
        (chunk: string) => {
          console.log("üìä Received chunk in UI:", chunk);
          setMessages((prev) => {
            return prev.map((msg) => {
              if (msg.id === initialAiMessage.id) {
                return {
                  ...msg,
                  content: (msg.content || "") + chunk,
                };
              }
              return msg;
            });
          });
        },
        // onComplete callback - finalize the response
        (fullResponse: string) => {
          console.log("‚úÖ Stream completed with full response:", fullResponse);
          setIsTyping(false);
          setCurrentAgent(null);

          // If no content was received, show a fallback message
          if (!fullResponse || fullResponse.trim() === "") {
            console.warn(
              "‚ö†Ô∏è Empty response received, showing fallback message"
            );
            setMessages((prev) => {
              return prev.map((msg) => {
                if (msg.id === initialAiMessage.id) {
                  return {
                    ...msg,
                    content:
                      "Xin l·ªói, t√¥i kh√¥ng th·ªÉ t·∫°o ph·∫£n h·ªìi cho y√™u c·∫ßu n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.",
                  };
                }
                return msg;
              });
            });
          }
        },
        // onError callback - handle errors
        (error: Error) => {
          console.error("‚ùå Stream error:", error);
          setIsTyping(false);
          setCurrentAgent(null);

          setMessages((prev) => {
            return prev.map((msg) => {
              if (msg.id === initialAiMessage.id) {
                return {
                  ...msg,
                  content:
                    "ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu. Vui l√≤ng th·ª≠ l·∫°i sau.",
                };
              }
              return msg;
            });
          });
        }
      );

      console.log("‚úÖ processStreamingResponse completed with result:", result);
    } catch (error) {
      console.error("‚ùå Error in handleSendMessage:", error);
      console.error(
        "‚ùå Error stack:",
        error instanceof Error ? error.stack : "No stack trace"
      );
      setIsTyping(false);
      setCurrentAgent(null);

      // Update the AI message with error content
      setMessages((prev) => {
        return prev.map((msg) => {
          if (msg.id === initialAiMessage.id) {
            return {
              ...msg,
              content: "H·ªá th·ªëng ƒëang n√¢ng c·∫•p, vui l√≤ng quay l·∫°i sau √≠t ph√∫t!",
            };
          }
          return msg;
        });
      });
    }
  };

  return (
    <div className="agent-chat-area flex flex-col h-full bg-white dark:bg-st-dark-secondary">
      <div className="chat-messages flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((message) => (
          <AgentMessage
            key={message.id}
            content={message.content}
            time={message.timestamp.toLocaleTimeString()}
            sender={message.sender}
            agentName={message.metadata?.agentName}
          />
        ))}
        {isTyping && (
          <div className="agent-typing-indicator flex items-center gap-2">
            <img
              className="w-5 h-5 loading-icon"
              src="/icon-wait.png"
              alt="Loading..."
            />
            <div className="loading-text text-sm italic">
              {currentAgent
                ? `${currentAgent} ƒëang ph·∫£n h·ªìi...`
                : "ƒêang x·ª≠ l√Ω..."}
            </div>
          </div>
        )}
      </div>

      <div className="chat-input-container border-t border-gray-200 dark:border-st-dark-border">
        <AgentChatInput
          value={inputValue}
          onChange={setInputValue}
          onSend={handleSendMessage}
          disabled={isTyping}
          isLoading={isTyping}
        />
      </div>
    </div>
  );
};
